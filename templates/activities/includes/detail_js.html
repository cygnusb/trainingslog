<!-- bring in the OpenLayers javascript library
 (here we bring it from the remote site, but you could
 easily serve up this javascript yourself) 
<script src="http://www.openlayers.org/api/OpenLayers.js"></script> -->
<script src="/media/js/openlayers/OpenLayers.js"></script>
<!-- bring in the OpenStreetMap OpenLayers layers.
 Using this hosted file will make sure we are kept up
 to date with any necessary changes -->
<script src="http://www.openstreetmap.org/openlayers/OpenStreetMap.js"></script>

<script type="text/javascript">
	var tooltips_visible = false;
	var plotselection_active = false;
	var plotselection_range = new Object();
	var plots = new Object();
	var legends = new Object();

	{% if activity.sport.speed_as_pace %}
		var speed_as_pace = true;
		var speed_unit = "Minuten/km";
	{% else %}
		var speed_as_pace = false;
		var speed_unit = "km/h";
	{% endif %}
	var plot_base="distance";
	{%	if activity.public %}
		var act_is_public = true;
	{%	else %}
		var act_is_public = false;
	{%	endif %}
	var distanceSuffixFormatter = function(val, axis) {
			if (val >= 1000)
				return (val / 1000).toFixed(axis.tickDecimals) + "km";
			else
				return val.toFixed(axis.tickDecimals) + "m";
		};


{% if tcx %}
	var graphs = [
		{ "name": "hf", "dataname": "hf", "label": "HF", "label_short": "HF","rounding": 0, "unit": "/ Minute", "unit_short": "/ min."},
		{ "name": "speed", "dataname": "speed", "label": "Geschwindigkeit", "label_short": "Geschw.", "rounding": 1, "unit": speed_unit, "unit_short": speed_unit},
		{ "name": "alt", "dataname": "altitude", "label": "Hoehe", "label_short": "Hoehe", "rounding": 0, "unit": "m", "unit_short": "m"},
		{ "name": "cad", "dataname": "cadence", "label": "Trittfrequenz", "label_short": "Trittfreq.", "rounding": 0, "unit": "/ Minute","unit_short": "/ min."}
	];	
{% else %}
	var graphs = [];
{% endif %}
	
	
{%  if gpx_url %}
	function show_map_selection() {
		if(layerMarkers) {
			var size = new OpenLayers.Size(21,25);
			var offset = new OpenLayers.Pixel(-(size.w/2), -size.h);
			var start_icon = new OpenLayers.Icon('http://openlayers.org/api/img/marker-green.png', size, offset);
			var end_icon = new OpenLayers.Icon('http://www.openlayers.org/dev/img/marker.png', size.clone(), offset.clone());
			var start_lonLat = new OpenLayers.LonLat(plot_data_raw["pos"][plotselection_range["edge_samples"][0]][1], plot_data_raw["pos"][plotselection_range["edge_samples"][0]][0]).transform(new OpenLayers.Projection("EPSG:4326"),details_map.getProjectionObject());
			var end_lonLat = new OpenLayers.LonLat(plot_data_raw["pos"][plotselection_range["edge_samples"][1]][1], plot_data_raw["pos"][plotselection_range["edge_samples"][1]][0]).transform(new OpenLayers.Projection("EPSG:4326"), details_map.getProjectionObject());

			// Remove markers from previous selection
			if(start_marker){
				layerMarkers.removeMarker(start_marker);
				start_marker = null;
			}
			if(end_marker){
				layerMarkers.removeMarker(end_marker);
				end_marker = null;
			}
			start_marker = new OpenLayers.Marker(start_lonLat,start_icon)
			end_marker = new OpenLayers.Marker(end_lonLat,end_icon)
			layerMarkers.addMarker(start_marker);
			layerMarkers.addMarker(end_marker);
		}
		if(layerSelection) {
			// Remove previous selection features
			layerSelection.removeAllFeatures();
		
			var selection_points = plot_data_raw["pos"].slice(plotselection_range["edge_samples"][0], plotselection_range["edge_samples"][1]);
			var points = new Array();
			for(var i in selection_points){
				var cur_point = new OpenLayers.Geometry.Point(selection_points[i][1], selection_points[i][0]).transform(new OpenLayers.Projection("EPSG:4326"), details_map.getProjectionObject());
				points.push(cur_point);
			}

			var line = new OpenLayers.Geometry.LineString(points);
			var style = { 
				strokeColor: '#0000ff', 
				strokeOpacity: 0.5,
				strokeWidth: 10
			};
			var lineFeature = new OpenLayers.Feature.Vector(line, null, style);
			layerSelection.addFeatures([lineFeature]);
		}
	}
{% endif %}
	
	function show_plots_selection() {
		for( var graph in graphs ){
			plot = plots[graphs[graph]["name"]];
			plot.setSelection({ xaxis: { from: plotselection_range["xaxis_range"][0], to: plotselection_range["xaxis_range"][1]}});
		}
	}
	
	function hide_plots_selection() {
		//deselect range in other graphs
		for (var graph2 in graphs){
			plot = plots[graphs[graph2]["name"]];
			plot.clearSelection();
		}
	}
	

{%  if gpx_url %}
	function hide_map_selection() {
		// Remove markers from map
		if(start_marker){
			layerMarkers.removeMarker(start_marker);
			start_marker = null;
		}
		if(end_marker){
			layerMarkers.removeMarker(end_marker);
			end_marker = null;
		}
		layerSelection.removeAllFeatures();
	}
{% endif %}

	function hide_tooltips() {
		// Hide tooltip for each graph
		if(tooltips_visible) {
			for (var graph in graphs){
				plot = plots[graphs[graph]["name"]];
				plot.clearSelection();
				$("#details_"+graphs[graph]["name"]+"_container").tooltip("disable").tooltip("close");
			}
		
			{%  if gpx_url %}
			// Hide map tooltip
			$("#details_map_tooltip").tooltip("disable").tooltip("close");
			{% endif %}
			tooltips_visible = false;
		}
	}
	
	function show_tooltips () {
		// Update tooltip text
		for(var graph in graphs){
			var range_values = range_data(plot_data_raw[graphs[graph]["dataname"]].slice(plotselection_range["edge_samples"][0], plotselection_range["edge_samples"][1]));
			if (range_values.min != false && range_values.max != false) {

				if (graphs[graph]["unit"]=="Minuten/km") {
					text = "<tr><td>Min. " + graphs[graph]["label_short"] + "</td><td>" + secondsToTime(range_values.min*60, with_hours=false) + " " + graphs[graph]["unit_short"] + "</td></tr>";
					text = text + "<tr><td>Max. " + graphs[graph]["label_short"] + "</td><td>" + secondsToTime(range_values.max*60, with_hours=false) + " " + graphs[graph]["unit_short"] + "</td></tr>";
					text = text + "<tr><td>Avg. " + graphs[graph]["label_short"] + "</td><td>" + secondsToTime(range_values.avg*60, with_hours=false) + " " + graphs[graph]["unit_short"] + "</td></tr>";
				} else {
					text = "<tr><td>Min. " + graphs[graph]["label_short"] + "</td><td>" + range_values.min.toFixed(graphs[graph]["rounding"]) + " " + graphs[graph]["unit_short"] + "</td></tr>";
					text = text + "<tr><td>Max. " + graphs[graph]["label_short"] + "</td><td>" + range_values.max.toFixed(graphs[graph]["rounding"]) + " " + graphs[graph]["unit_short"] + "</td></tr>";
					text = text + "<tr><td>Avg. " + graphs[graph]["label_short"] + "</td><td>" + range_values.avg.toFixed(graphs[graph]["rounding"]) + " " + graphs[graph]["unit_short"] + "</td></tr>";
				}
			//	text = text + "<tr><td>" + graphs[graph2]["label"] + "</td><td>" + range_data.min.toFixed(graphs[graph]["rounding"]) + " - " + range_data.max.toFixed(graphs[graph]["rounding"]);
			}
			$("#details_"+graphs[graph]["name"]+"_container").tooltip( "option", "content", "<table>"+text+"</table>");
		}
		{% if gpx_url %}
		text = "<table>";
		for(var graph2 in graphs){
			var dataname = graphs[graph2]["dataname"];
			if(plot_data_raw[dataname].length > plotselection_range["edge_samples"][1]){
				var distance = plot_data_raw[dataname][plotselection_range["edge_samples"][1]][0] - plot_data_raw[dataname][plotselection_range["edge_samples"][0]][0]
				var duration = plot_data_raw[dataname][plotselection_range["edge_samples"][1]][1] - plot_data_raw[dataname][plotselection_range["edge_samples"][0]][1]
				text = text + "<tr><td>Distanz</td><td>" + (distance/1000).toFixed(2) + " km</td></tr>";
				text = text + "<tr><td>Dauer</td><td>" + secondsToTime((duration/1000), with_hours=true) + " h</td></tr>";
				if(duration > 0 && distance > 0) {
					if(speed_as_pace){
						text = text + "<tr><td>Ø Geschw.</td><td>"+secondsToTime(duration/distance, with_hours=false)+" min/km</td></tr>";
					} else {
						text = text + "<tr><td>Ø Geschw.</td><td>"+(distance*3600/duration).toFixed(1).toString().replace('.', ',')+" km/h</td></tr>";
					}
				}
			
				break;
			}
		}
		text = text + "</table>"
		$("#details_map_tooltip").tooltip("option", "content", text);
		{% endif %}
		
		
		// show tooltip
		if(!tooltips_visible){
			for(var graph in graphs){
				$("#details_"+graphs[graph]["name"]+"_container")
						.tooltip( "option", "position",  { my: "right-10 bottom-25", at: "right bottom", collision: "none" })
						.tooltip("open");
			}

			{% if gpx_url %}
			$("#details_map_tooltip")
				.tooltip( "option", "position",  { my: "right-10 bottom-10", at: "right top", collision: "none" })
				.tooltip("open");
			{% endif %}

			tooltips_visible = true;
		}
	}

	$(document).ready(function() {
		$( "#details_overview" ).accordion({collapsible: true});
		$( "#details_details" ).accordion({collapsible: true});
		$( "#details_weather" ).accordion({collapsible: true});
		$( "#laps_laps").accordion();
		$( "#details_tabs" ).tabs({
			activate: function(event ,ui){
				// hide tooltips when switching to laps tab
				plot_lock_selection_cb = true;
				if(ui.newTab.index() == 1 & tooltips_visible){
					hide_tooltips();
				}
				//show tooltips when switching to details tab, restore selection in plots
				if(ui.newTab.index() == 0 & plotselection_active){
					show_tooltips();
					show_plots_selection();
				}
				plot_lock_selection_cb = false;
			}
		});
	
{% if tcx %}
		$( "#details_map" ).accordion({collapsible: true});
		for (var i in graphs) {
			$( "#details_"+graphs[i]["name"] ).accordion({collapsible: true});
		}
		$( "#plot_xaxis").change(plot_xaxis_changed);
		plot_graphs();
{% endif %}
{% if gpx_url %}
		init_map();
{% endif %}
	});

{% if tcx %}
	plot_data = new Object();
	var plot_data_raw;
	var plot_lock_selection_cb = false;
	var plot_graphs = function() {
		var url = "/activities/{{ activity.id }}/?p=plots";
	
		function onDataReceived(data) {
			plot_data_raw = data;
			update_plots();
		}


		$.ajax({
			async : true,
			url : url,
			dataType : "json",
			success : onDataReceived
		});

	};

	var range_data = function(data){
		// TODO Calculate average over time
		var min = false;
		var max = false;
		var avg = false;
		var last_ts = false;
		var avg_count = 0;
		for(var i in data){
			var x = data[i][1];
			var y= data[i][2];

			// calculation of min/max
			if(min == false || min > y)
				min = y;
			if( max == false || max < y)
				max = y;

			// calculation of average
			if(last_ts != false ) {
				avg = avg + y * (x - last_ts);
				avg_count = avg_count + (x - last_ts);
				last_ts = x;
			} else {
				// first sample...
				last_ts = x;
				avg = 0;
			}
		}

		if(avg_count > 0) {
			avg = avg / avg_count;
		}
		
		res = new Object();
		res.min = min;
		res.max = max;
		res.avg = avg;
		return res;
	}

	var range_edge_samples = function(range_min, range_max) {
		// find index of first and last sample in selection range
		for(var graph in graphs){
			var dataname = graphs[graph]["dataname"];
			if(plot_data_raw[dataname].length > 0){
				for(var i in plot_data_raw[dataname]) {
					var sample = plot_data_raw[dataname][i];
					if(plot_base == "distance" ){
						if( sample[0] >= range_min ) {
							var range_start = i;
							break;
						}
					} else {
						if( sample[1] >= range_min ) {
							var range_start = i;
							break;
						}
					}
				}
				for(var i in plot_data_raw[dataname]) {
					sample = plot_data_raw[dataname][i];
					if(plot_base == "distance" ){
						if( sample[0] >= range_max ) {
							var range_end = i;
							break;
						}
					} else {
						if( sample[1] >= range_max ) {
							var range_end = i;
							break;
						}
					}
				}
				break;
			}
		}
		return [range_start, range_end]
	}

	var update_plots = function() {
		function cloneObject(obj) {
			var clone = {};
			for(var i in obj) {
				if(typeof(obj[i])=="object")
					clone[i] = cloneObject(obj[i]);
				else
					clone[i] = obj[i];
			}
			return clone;
		}

		var data = plot_data_raw;
		
		plot_default_options = {
			xaxis : {
				tickDecimals: "1",
				tickFormatter: distanceSuffixFormatter
			},
			crosshair : {
				mode : "x"
			},
			grid : {
				hoverable : true,
				autoHighlight : false
			},
			selection: { mode: "x" }
		}

		for (i in graphs) {
			plot_data[graphs[i]["name"]]=new Object();
			plot_data[graphs[i]["name"]]["label"]=graphs[i]["label"]+" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "+graphs[i]["unit"];
			plot_data[graphs[i]["name"]]["lines"]={"show": true, "lineWidth": 1, "fill": 0.2};
			plot_data[graphs[i]["name"]]["points"]={"show": false};
			plot_data[graphs[i]["name"]]["color"]="#0070A3";
			
			if(data[graphs[i]["dataname"]].length == 0) {
				plot_data[graphs[i]["name"]]["data"] = [];
				$("#details_"+graphs[i]["name"]).hide();
				
				// Delete entry from graph list for non-existing graphs
				delete graphs[i];
			} else {
				var gdata=transpose(data[graphs[i]["dataname"]]);
				if(plot_base == "time"){
					var graphdata=transpose([gdata[1], gdata[2]]);
					plot_data[graphs[i]["name"]]["data"]=graphdata;
					
					plot_default_options["xaxis"] = {
						mode: "time",
						timeformat: "%H:%Mh"
					};
				} else {
					var graphdata=transpose([gdata[0], gdata[2]]);
					plot_data[graphs[i]["name"]]["data"]=graphdata;
					
					plot_default_options["xaxis"] = {
						tickDecimals: "1",
						tickFormatter: distanceSuffixFormatter
					}
				}
			}
		}

		pace_plot = {
			transform: function(v) { return -v; },
			inverseTransform: function (v) { return -v; },
			ticks: function (axis) {
				var res = [], i = Math.floor(axis.min);
				do {
					res.push([i,secondsToTime(i*60, with_hours=false)]);
					i=i+0.5;
				} while (i<axis.max);
				return res;
			}
		}
			
		for (var i in graphs) {
			plot_options = cloneObject(plot_default_options);
			if (plot_data[graphs[i]["name"]]["data"].length>0) {
				var avg=0;
				var min=plot_data[graphs[i]["name"]]["data"][0][1];
				var max=plot_data[graphs[i]["name"]]["data"][0][1];
				for (var j=0; j<plot_data[graphs[i]["name"]]["data"].length; j++) {
					avg=avg+plot_data[graphs[i]["name"]]["data"][j][1];
					if (plot_data[graphs[i]["name"]]["data"][j][1]<min)
						min=plot_data[graphs[i]["name"]]["data"][j][1];
					if (plot_data[graphs[i]["name"]]["data"][j][1]>max)
						max=plot_data[graphs[i]["name"]]["data"][j][1];
				}
				avg=avg/plot_data[graphs[i]["name"]]["data"].length;
			}
			if ((graphs[i]["name"]=="speed") && speed_as_pace) {
				plot_options["yaxis"]=pace_plot;
				plot_options["yaxis"]["min"]=Math.floor(min);
				plot_options["yaxis"]["max"]=Math.floor(1.5*avg);
			} else {
				plot_options["yaxis"]=new Object();
				plot_options["yaxis"]["min"]=Math.floor(0.5*avg);
				plot_options["yaxis"]["max"]=Math.ceil(1.1*max);
			}

			plots[graphs[i]["name"]]= $.plot($("#details_"+graphs[i]["name"]+"_container"), [plot_data[graphs[i]["name"]]], plot_options);
			legends[graphs[i]["name"]] = $("#details_"+graphs[i]["name"]+"_container .legendLabel");
			legends[graphs[i]["name"]].each(function() {
				$(this).css('width', $(this).width());
			});
		}
		
		var updateCursorTimeout = null;
		var latestPosition = null;
		
		
		function updateCursor() {
			updateCursorTimeout = null;
			var pos = latestPosition;
			if(pos){
				{%  if gpx_url %}
				var sample = range_edge_samples(pos.x, pos.x)[0];
				if( sample !== undefined ) {
					if(cursor_marker) {
						layerCursor.removeMarker(cursor_marker);
					}
					var size = new OpenLayers.Size(21,25);
					var offset = new OpenLayers.Pixel(-(size.w/2), -size.h);
					var cursor_icon = new OpenLayers.Icon('http://openlayers.org/api/img/marker-blue.png', size, offset);
					var cursor_lonLat = new OpenLayers.LonLat(plot_data_raw["pos"][sample][1], plot_data_raw["pos"][sample][0]).transform(new OpenLayers.Projection("EPSG:4326"),details_map.getProjectionObject());
					cursor_marker = new OpenLayers.Marker(cursor_lonLat,cursor_icon)
					layerCursor.addMarker(cursor_marker);
				}
				{% endif %} //gpx_url
				for (var graph in graphs) {
					plot = plots[graphs[graph]["name"]];
					legend = legends[graphs[graph]["name"]];

					plot.setCrosshair(pos);
					axes = plot.getAxes();
					if(pos.x < axes.xaxis.min || pos.x > axes.xaxis.max)
						continue;

					var i, j, dataset = plot.getData();
					for( i = 0; i < dataset.length; ++i) {
						var series = dataset[i];

						// find the nearest points, x-wise
						for( j = 0; j < series.data.length; ++j)
							if(series.data[j][0] > pos.x)
								break;

						// now interpolate
						var y, p1 = series.data[j - 1], p2 = series.data[j];
						if(p1 == null)
							y = p2[1];
						else if(p2 == null)
							y = p1[1];
						else
							y = p1[1] + (p2[1] - p1[1]) * (pos.x - p1[0]) / (p2[0] - p1[0]);
						if (graphs[graph]["unit"]=="Minuten/km") {
							newvalue = secondsToTime(y*60, with_hours=false);
						} else {
							newvalue = y.toFixed(graphs[graph]["rounding"]);
						}
						legend.eq(i).text(graphs[graph]["label"]+" "+newvalue+" "+graphs[graph]["unit"]);
					}
				}
			} else {
				{%  if gpx_url %}
				if(cursor_marker) {
					layerCursor.removeMarker(cursor_marker);
				}
				{% endif %}
				for (var graph in graphs) {
					plot = plots[graphs[graph]["name"]];
					legend = legends[graphs[graph]["name"]];

					plot.clearCrosshair();

					var i, j, dataset = plot.getData();
					for( i = 0; i < dataset.length; ++i) {
						legend.eq(i).text(graphs[graph]["label"]+" "+graphs[graph]["unit"]);
					}
				}
			}
		}
		
		for (var graph in graphs) {
			// Add tooltip
			$("#details_"+graphs[graph]["name"]+"_container").tooltip({
					disabled: true,
					position: { my: "right-10 bottom-25", at: "right bottom", collision: "none" },
					tooltipClass: "details_plot_tooltip",
			});
			$("#details_"+graphs[graph]["name"]+"_container").bind("plothover", function(event, pos, item) {
				latestPosition = pos;
				if(!updateCursorTimeout)
					updateCursorTimeout = setTimeout(updateCursor, 50);
			});
			$("#details_"+graphs[graph]["name"]+"_container").bind('mouseleave', function(event) {
				latestPosition = null;
				updateCursor();
				event.stopImmediatePropagation();
			});
			$("#details_"+graphs[graph]["name"]+"_container").bind("plotselected", function (event, ranges) {
				if (plot_lock_selection_cb==false){
					plot_lock_selection_cb = true;
					plotselection_active = true;
					plotselection_range["xaxis_range"] = [ranges.xaxis.from, ranges.xaxis.to];
					plotselection_range["edge_samples"] = range_edge_samples(ranges.xaxis.from, ranges.xaxis.to);
					
					{%  if gpx_url %}
					show_map_selection();
					{% endif %}
					show_plots_selection();
					show_tooltips();
					
					plot_lock_selection_cb = false;
				}
			});

			$("#details_"+graphs[graph]["name"]+"_container").bind("plotunselected", function (event) {
				if (plot_lock_selection_cb == false ) {
					plot_lock_selection_cb = true;
					plotselection_active = false
					
					{%  if gpx_url %}
					hide_map_selection()
					{% endif %}
					hide_plots_selection();
					hide_tooltips();
					plot_lock_selection_cb = false;
				}
			});
		}
		return data;
	}
	

	{%  if gpx_url %}
	var map; //complex object of type OpenLayers.Map

	var init_map = function () {
		details_map = new OpenLayers.Map ("details_map_container", {
			controls:[
				new OpenLayers.Control.Navigation(),
				new OpenLayers.Control.PanZoomBar(),
				new OpenLayers.Control.LayerSwitcher(),
				new OpenLayers.Control.Attribution()],
			maxExtent: new OpenLayers.Bounds(-20037508.34,-20037508.34,20037508.34,20037508.34),
			maxResolution: 156543.0399,
			numZoomLevels: 19,
			units: 'm',
			projection: new OpenLayers.Projection("EPSG:900913"),
			displayProjection: new OpenLayers.Projection("EPSG:4326")
		} );
		
		populate_map(details_map);

		$("#details_map_tooltip").tooltip({
			disabled: true,
			tooltipClass: "details_plot_tooltip",
		});
	}
	
	var populate_map = function(map) {
		// Define the map layer
		// Here we use a predefined layer that will be kept up to date with URL changes
		layerMapnik = new OpenLayers.Layer.OSM("Mapnik");
		layerCycleMap = new OpenLayers.Layer.OSM("OpenCycleMap",
				  ["http://a.tile.opencyclemap.org/cycle/${z}/${x}/${y}.png",
				   "http://b.tile.opencyclemap.org/cycle/${z}/${x}/${y}.png",
				    "http://c.tile.opencyclemap.org/cycle/${z}/${x}/${y}.png"]);
		layerMarkers = new OpenLayers.Layer.Markers("Markers");
		layerCursor = new OpenLayers.Layer.Markers("Cursor");
		layerSelection = new OpenLayers.Layer.Vector("Selection");
		map.addLayer(layerMapnik);
		map.addLayer(layerCycleMap);

		start_marker = null;
		end_marker = null;
		cursor_marker = null;

		// Add the Layer with the GPX Track
		var layerGPX = new OpenLayers.Layer.Vector("Track", {
			protocol: new OpenLayers.Protocol.HTTP({
				url: "{{ gpx_url }}",
				format: new OpenLayers.Format.GPX({extractWaypoints: true, extractRoutes: true, extractAttributes:true})
			}),
			strategies: [ new OpenLayers.Strategy.Fixed()],
			style: {strokeColor: "red", strokeWidth: 5, strokeOpacity: 0.5},
			projection: new OpenLayers.Projection("EPSG:4326")
		});
		map.addLayer(layerGPX);

		map.addLayer(layerSelection);
		map.addLayer(layerMarkers);
		map.addLayer(layerCursor);

//		var lonLat = new OpenLayers.LonLat(lon, lat).transform(new OpenLayers.Projection("EPSG:4326"), map.getProjectionObject());
//		map.setCenter(lonLat, zoom);
		layerGPX.events.register('loadend', details_map, function(){
			this.zoomToExtent(layerGPX.getDataExtent())
		});
		map.setCenter(null, null);

		// show map
		$("#details_map_container").css('visibility', 'visible');
	}
	{% endif %} // gpx_url

{% endif %}


	var plot_xaxis_changed = function () {
		if( $("#plot_xaxis").val() == 0) {
			plot_base = "distance";
		} else {
			plot_base = "time"
		}
		update_plots();
	}
</script>

{% if not public %}
	{% if fb_app_id %}
		<script>
			window.fbAsyncInit = function() {
				// init the FB JS SDK
				FB.init({
					appId: "{{fb_app_id}}",
					status : false, // check the login status upon init?
				});
			};
		
			var postToFeed = function() {
				if( act_is_public ){
					var desc = new Array();
					{% if activity.time %}
					desc.push('Zeit: {{ activity.time }}');
					{% endif %}
									{% if activity.distance %}
									desc.push('Distanz: {{ activity.distance }} km');
									{% endif %}
									{% if activity.speed_avg  %}
									desc.push('Geschwindigkeit Ø: {{ activity.speed_avg }} '+speed_unit);
									{% endif %}
									{% if activity.hf_avg  %}
									desc.push('HF Ø: {{ activity.hf_avg }}');
									{% endif %}
									{% if activity.calories	 %}
									desc.push('Kalorien: {{ activity.calories }}');
									{% endif %}


					var obj = {
						method: 'feed',
						link: '{{ full_url }}',
						name: '{{ activity.name }}',
						{% if activity.comment	%}
						caption: '{{ activity.comment|linebreaksbr }}',
						{% else %}
						caption: ' ',
						{% endif %}
						picture: '{{ preview_img }}',
						description: desc.join(" - ")
					};

			
					function callback(response) {
						document.getElementById('msg').innerHTML = "Post ID: " + response['post_id'];
					}
				
					FB.ui(obj, callback);
				} else {
					noty({text: "Aktivit&auml;t ist nicht &ouml;ffentlich", type: 'error', timeout: 5000});
				}
			};
		
		// Load the SDK's source Asynchronously
		// Note that the debug version is being actively developed and might 
		// contain some type checks that are overly strict. 
		// Please report such bugs using the bugs tool.
		(function(d, debug){
			var js, id = 'facebook-jssdk', ref = d.getElementsByTagName('script')[0];
			if (d.getElementById(id)) {return;}
			js = d.createElement('script'); js.id = id; js.async = true;
			js.src = "//connect.facebook.net/en_US/all" + (debug ? "/debug" : "") + ".js";
			ref.parentNode.insertBefore(js, ref);
		}(document, /*debug*/ false));
		</script>

	{% endif %}
{% endif %}
